<!DOCTYPE html>
<html>
	<head>
		<title>Paper Mini Gen</title>
		<link rel="shortcut icon" href="#" />
		<!-- IMAGE UPLOAD  -->
		<script type="text/javascript" src="/lib/on-image-selection.js"></script>
		<!-- IMAGE SILHOUETTING -->
		<!-- https://www.lactame.com/lib/image-js/0.21.2/image.min.js -->
		<script type="text/javascript" src="/lib/image.min.js"></script>
		<script type="text/javascript" src="/lib/get-input-as-int.js"></script>
		<script type="text/javascript" src="/lib/apply-threshold.js"></script>
		<!-- IMAGE TRACING -->
		<script type="text/javascript" src="/lib/imagetracer_v1.2.6.js"></script>
		<!-- IMAGE TRACING CLEANUP -->
		<script type="text/javascript" src="/lib/pathseg.js"></script>
		<script type="text/javascript" src="/lib/path-to-polygon.js"></script>
		<!-- OFFSET PATH -->
		<script src="/lib/bezier.js" type="text/javascript"></script>
		<script
			src="https://microsoft.github.io/maker.js/target/js/browser.maker.js"
			type="text/javascript"
		></script>
		<script
			src="https://danmarshall.github.io/svg-path-outline/browser/index.js"
			type="text/javascript"
		></script>
		<!-- BOOLEAN ADDITION -->
		<script
			type="text/javascript"
			src="/lib/polybooljs-1.2.2/dist/polybool.js"
		></script>
		<script type="text/javascript" src="/lib/render-paths-string.js"></script>
		<script type="text/javascript" src="/lib/render-polygon-as-svg.js"></script>
	</head>
	<body>
		<!--  -->
		<!--  -->
		<!--  -->
		<h2>IMAGE UPLOAD</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<p>
			<input
				type="file"
				id="image-input"
				accept="image/png, image/jpeg"
				onchange="onImageSelection(this, 'image-preview')"
			/>
		</p>
		<p>
			<img id="image-preview" src="/sample-char-art-00.jpeg" />
		</p>

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>IMAGE SILHOUETTING</h2>
		<!--  -->
		<!--  -->
		<!--  -->
		<script>
			async function processImage() {
				// Load the original raw image from a source element
				const imgElem = document.getElementById("image-preview");
				// Gather optional settings
				const threshold = getInputAsInt("threshold") / 100;
				const radius = getInputAsInt("radius");
				// Proces the image
				const processedSrc = await applyThreshold(
					imgElem.src,
					threshold,
					radius
				);
				// Load the image into a destination element
				document.getElementById("processed-image").src = processedSrc;
			}
		</script>

		<!-- TODO: maybe just maybe use CSS filters to "preview" threshold changes? -->
		<p>
			Threshold
			<input id="threshold" type="number" min="0" max="100" value="50" />
		</p>
		<p>
			Radius
			<input id="radius" type="number" min="1" max="100" value="1" />
		</p>
		<p><button onClick="processImage()">Process image</button></p>
		<img id="processed-image" />

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>IMAGE TRACING</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<script>
			function traceImage() {
				/**
				 * NOTE: uses https://github.com/jankovicsandras/imagetracerjs
				 */
				const pathomit = getInputAsInt("pathomit");
				const ltres = getInputAsInt("ltres");
				const qtres = getInputAsInt("qtres");
				// Adding custom palette. This will override numberofcolors.
				// Loading an image, tracing with the 'posterized2' option preset, and appending the SVG to an element with id="svgcontainer"
				const imageSource = document
					.getElementById("processed-image")
					.getAttribute("src");

				function doneTracingCallback(svgString) {
					document.getElementById("svgcontainer").innerHTML = "";
					ImageTracer.appendSVGString(svgString, "svgcontainer");
				}
				/**
				 * TODO: is there a way to trace with straight lines only?
				 * Could simplify the process dramatically...
				 */
				ImageTracer.imageToSVG(
					imageSource /* input filename / URL */,
					doneTracingCallback,
					{
						pathomit,
						ltres,
						qtres,
						colorsampling: 0,
						colorquantcycles: 1,
						strokewidth: 0,
						roundcoords: 2,
						/**
						 * Set a custom palette, of:
						 * - black (foreground shapes)
						 * - nearly-white (background shapes, will remove in later step)
						 */
						pal: [
							{ r: 0, g: 0, b: 0, a: 255 },
							{ r: 245, g: 245, b: 245, a: 255 },
						],
					}
				);
			}
		</script>

		<p><button onClick="traceImage()">Trace Image</button></p>
		<p>OPTIONS</p>
		<p>Path omit: <input id="pathomit" type="number" min="0" value="30" /></p>
		<p>
			Line error threshold:
			<input id="ltres" type="number" min="1" value="2" />
		</p>
		<p>
			Quadratic split error threshold:
			<input id="qtres" type="number" min="1" value="2" />
		</p>
		<div id="svgcontainer"></div>

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>CLEANUP TRACE</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<script>
			function cleanupTrace() {
				/**
				 * Clone the SVG generated at the previous step
				 */
				const cleanedTraceContainer = document.getElementById(
					"svgcontainer_cleanup"
				);
				cleanedTraceContainer.innerHTML =
					document.getElementById("svgcontainer").innerHTML;
				/**
				 * Retain only the "foreground" paths.
				 *
				 * We only want to outline and boolean add the traced paths
				 * that are "foreground" (ie black). Speficially, remove paths with
				 * `fill="rgb(245,245,245)"`. Note this specific colour was set
				 * in the palette of the trace in an earlier step.
				 */
				cleanedTraceContainer
					.querySelectorAll(`path[fill="rgb(245,245,245)"]`)
					.forEach((e) => e.remove());
				/**
				 * Convert the foreground paths, which may include curves,
				 * to polygons, which will consist of straigh lines only.
				 *
				 * The current approach is swiped from:
				 * https://betravis.github.io/shape-tools/path-to-polygon/
				 *
				 * That being said, it doesn't seem to do _any_ sampling along
				 * curves... instead it only keeps the control points. Maybe
				 * it'd be possible to improve the tracing further by combining
				 * the "retain all control points" approach with a
				 * "sample along the line" approach... perhaps sampling along
				 * the line only for curved segments? This is a deep dive though,
				 * and certainly not something I intend to try to tackle at this time.
				 * More the sample-along-the-line approach:
				 * https://phrogz.net/SVG/convert_path_to_polygon.xhtml
				 * And there's a very naive implementation in:
				 * `basic-point-at-length.html` (in this repo)
				 */
				convertPathsToPolygon(cleanedTraceContainer.querySelector("svg"));
			}
		</script>

		<ul>
			<li>Retain "foreground" elements only</li>
			<li>Convert curves lines to straight lines</li>
		</ul>
		<p><button onClick="cleanupTrace()">cleanupTrace()</button></p>
		<div id="svgcontainer_cleanup"></div>

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>PATH OFFSET</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<script>
			/* https://danmarshall.github.io/svg-path-outline/ */
			var spo = require("svg-path-outline");

			function buildSvgNode(n, v) {
				n = document.createElementNS("http://www.w3.org/2000/svg", n);
				for (var p in v) n.setAttributeNS(null, p, v[p]);
				return n;
			}

			function applyOffset(svgSource, svgDestContainer = null) {
				let svgDest;
				if (svgDestContainer !== null) {
					svgDestContainer.innerHTML = svgSource.parentNode.innerHTML;
					svgDest = svgDestContainer.querySelector("svg");
				} else {
					svgDest = svgSource;
				}
				const offset = getInputAsInt("offset");
				// Remove any path elements from previous applications
				const pathElems = svgDest.querySelectorAll("path");
				for (const pathElem of pathElems) {
					pathElem.remove();
				}
				// From each polygon element, generate an offset path element
				const polygonElems = svgDest.querySelectorAll("polygon");
				for (const polygonElem of polygonElems) {
					const polygonData = polygonElem.getAttribute("points");
					const outlineData = spo(polygonData, offset, { tagName: "polygon" });
					const outlinePath = buildSvgNode("path", {
						d: outlineData,
						fill: "rgba(255,0,0,0.4)",
					});
					svgDest.appendChild(outlinePath);
				}
				/**
				 * TODO: maybe modify the viewBox and the width and height of the SVG?
				 * Otherwise, large offset values can result in cut-off shapes,
				 * as the offset shape can expand beyond the original SVG bounds.
				 *
				 * Example, for 10 units offset...
				 * go from viewBox "0 0 100 100", width 100, height 100,
				 * to viewBox "-10 -10 110 110", width 120, height 120
				 *
				 * function expandSvgViewbox(x, y)
				 */
			}
		</script>

		<script>
			function convertOffsetPathsToPolygons(
				svgSource,
				svgDestContainer = null
			) {
				let svgDest;
				if (svgDestContainer !== null) {
					svgDestContainer.innerHTML = svgSource.parentNode.innerHTML;
					svgDest = svgDestContainer.querySelector("svg");
				} else {
					svgDest = svgSource;
				}
				// Remove polygon elements, the "not offset" original shapes
				const polygonElems = svgDest.querySelectorAll("polygon");
				for (const polygonElem of polygonElems) {
					polygonElem.remove();
				}
				// Convert the newly offset `path` nodes to `polygon`
				convertPathsToPolygon(svgDest);
			}
		</script>

		<p>
			Offset:
			<input id="offset" type="number" min="0" max="100" value="30" />
		</p>
		<button
			onClick="applyOffset(document.querySelector('#svgcontainer_cleanup svg'), document.querySelector('#svgcontainer_offset')); convertOffsetPathsToPolygons(document.querySelector('#svgcontainer_offset svg'))"
		>
			Apply offset
		</button>
		<div id="svgcontainer_offset"></div>

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>BOOLEAN ADDITION</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<script>
			function unionPolygonObjects(polygons) {
				var segments = PolyBool.segments(polygons[0]);
				for (var i = 1; i < polygons.length; i++) {
					var seg2 = PolyBool.segments(polygons[i]);
					var comb = PolyBool.combine(segments, seg2);
					segments = PolyBool.selectUnion(comb);
				}
				return PolyBool.polygon(segments);
			}

			function runUnion(svgSourceContainer, svgDestContainer = null) {
				const polygonElems = svgSourceContainer.querySelectorAll("polygon");
				const polygonObjs = [];
				for (const polygonElem of polygonElems) {
					polygonObjs.push(getPolygonAsPolyboolObj(polygonElem));
				}
				/**
				 * Union of many shapes, as pulled from examples:
				 * https://github.com/velipso/polybooljs?tab=readme-ov-file#advanced-example-1
				 */
				const unionPolygonObj = unionPolygonObjects(polygonObjs);
				/**
				 * TODO: renderPolygonAsSvg should be refactored.
				 * Part of it is inferring width and height of resulting SVG...
				 * but may actually want to explicitly provide those!
				 * Three different functions happening:
				 * - inferArtboardDimensions(polygonObj)
				 * - speculativeWindingOrderFix(polygonObj)
				 * - renderPathsString() (... already implemented)
				 * - renderSvg(pathsString) (... for markup and style decisions!)
				 */
				const unionSvg = renderPolygonAsSvg(unionPolygonObj);
				svgDestContainer.innerHTML = unionSvg;
			}

			function getPolygonAsPolyboolObj(polygonElem) {
				const points = polygonElem
					.getAttribute("points")
					.split(" ")
					.map((e) => e.trim())
					.filter((e) => e !== "")
					.map((e) => {
						const [xStr, yStr] = e.split(",");
						return [parseFloat(xStr), parseFloat(yStr)];
					});
				return {
					regions: [points],
					inverted: false,
				};
			}
		</script>

		<button
			onClick="runUnion(document.querySelector('#svgcontainer_offset'), document.querySelector('#svgcontainer_booleanunion'))"
		>
			Apply boolean union
		</button>
		<div id="svgcontainer_booleanunion"></div>

		<!--  -->
		<!--  -->
		<!--  -->
		<h2>Copy to Clipboard</h2>
		<!--  -->
		<!--  -->
		<!--  -->

		<script>
			async function copyTextToClipboard(text) {
				const blobText = new Blob([text], { type: "text/plain" });
				const data = [
					new ClipboardItem({
						["text/plain"]: blobText,
					}),
				];
				navigator.clipboard.write(data).then(
					() => {},
					() => {
						alert("Copy to clipboard failed for some reason.");
					}
				);
			}
		</script>

		<p>This serves as the "export" function... for now at least!</p>
		<button
			onClick="copyTextToClipboard(document.getElementById('svgcontainer_booleanunion').innerHTML)"
		>
			Copy to clipboard
		</button>
	</body>
</html>
