<!DOCTYPE html>
<html>
	<head>
		<title>Paper Mini Gen</title>
		<script src="/imagetracer_v1.2.6.js"></script>
		<script src="/lib/svg-path-to-polygon.js"></script>
		<style>
			svg path[fill="rgb(255,255,255)"] {
				/* TODO: great as a preview! but need to do in JS too... */
				/* display: none; */
			}
			svg path[fill="rgb(0,0,0)"] {
				/* TODO: great as a preview! but need to do in JS too... */
				/* TODO: add HTML slider that controls this somehow... */
				/* stroke-width: 15; */
			}
		</style>
	</head>
	<body>
		<p>
			<img src="/2025-04-03-test-outline-image.png" />
		</p>
		<p style="color: magenta">TODO: ADJUST CONTRAST OF IMAGE BEFORE TRACING</p>
		<a href="https://github.com/image-js/image-js"
			>https://github.com/image-js/image-js</a
		>
		<p><button onClick="traceImage()">Trace Image</button></p>
		<p>OPTIONS</p>
		<p>Path omit: <input id="pathomit" type="number" min="0" value="50" /></p>
		<p>
			Blur radius:
			<input id="blurradius" type="number" min="0" max="5" value="2" />
		</p>
		<p>
			Blur delta:
			<input id="blurdelta" type="number" min="0" max="100" value="20" />
		</p>
		<p>
			Line error threshold:
			<input id="ltres" type="number" min="1" value="5" />
		</p>
		<p>
			Quadratic split error threshold:
			<input id="qtres" type="number" min="1" value="5" />
		</p>
		<p>
			Polyline sample frequency:
			<input
				id="polylinesamplefrequency"
				type="number"
				min="1"
				max="200"
				value="40"
			/>
		</p>
		<div id="svgcontainer"></div>
		<p>FOREGROUND ELEMENTS ONLY</p>
		<div id="svgcontainer_foreground"></div>
		<p style="color: magenta">CONVERT PATHS TO POLYGONS</p>
		<div id="svgcontainer_polygon"></div>
		<p style="color: magenta">OFFSET PATHS</p>
		<p style="color: magenta">BOOLEAN ADDITION</p>
		<script>
			function traceImage() {
				// NOTE: uses https://github.com/jankovicsandras/imagetracerjs
				const pathomit = parseInt(document.getElementById("pathomit").value);
				const ltres = parseInt(document.getElementById("ltres").value);
				const qtres = parseInt(document.getElementById("qtres").value);
				const blurradius = parseInt(
					document.getElementById("blurradius").value
				);
				const blurdelta = parseInt(document.getElementById("blurdelta").value);
				// Adding custom palette. This will override numberofcolors.
				const options = {
					pathomit,
					blurradius,
					blurdelta,
					ltres,
					qtres,
					colorsampling: 0,
					colorquantcycles: 1,
					strokewidth: 0,
					roundcoords: 2,
					pal: [
						{ r: 0, g: 0, b: 0, a: 255 },
						{ r: 245, g: 245, b: 245, a: 255 },
					],
				};
				/**
				 * TODO: maybe try increasing the contrast of the image before
				 * trying to trace it?
				 * TODO: maybe allow user to INVERT the image before tracing it?
				 *
				 * https://github.com/image-js/image-js
				 */
				// Loading an image, tracing with the 'posterized2' option preset, and appending the SVG to an element with id="svgcontainer"
				ImageTracer.imageToSVG(
					"/2025-04-03-test-outline-image.png" /* input filename / URL */,
					function (svgstr) {
						document.getElementById("svgcontainer").innerHTML = "";
						ImageTracer.appendSVGString(svgstr, "svgcontainer");
						afterTrace();
					} /* callback function to run on SVG string result */,
					options
				);
			}

			function afterTrace() {
				/**
				 *
				 * Isolate so only "foreground" paths remain.
				 * We only want to outline and boolean add the traced paths
				 * that are "foreground" (ie black). Speficially, remove paths with
				 * `fill="rgb(255,255,255)"`.
				 *
				 * Maybe you could do this by cloning the inner HTML of "svgcontainer"
				 * to a new container... and then running operations on that container.
				 * Eg get element by attribute, where "fill" === "rgb(255,255,255)".
				 */
				const foreground = document.getElementById("svgcontainer_foreground");
				foreground.innerHTML =
					document.getElementById("svgcontainer").innerHTML;
				const backgroundPaths = document
					.querySelectorAll(
						`#svgcontainer_foreground path[fill="rgb(245,245,245)"]`
					)
					.forEach((e) => e.remove());

				/**
				 * TODO: look into converting paths to polygons
				 * https://www.npmjs.com/package/svg-path-to-polygons
				 * Another option: https://betravis.github.io/shape-tools/path-to-polygon/
				 * More of a deep dive: https://phrogz.net/SVG/convert_path_to_polygon.xhtml
				 */
				const polylinesamplefrequency = parseInt(
					document.getElementById("polylinesamplefrequency").value
				);
				const polygonSvgContainer = document.getElementById(
					"svgcontainer_polygon"
				);
				polygonSvgContainer.innerHTML = document.getElementById(
					"svgcontainer_foreground"
				).innerHTML;
				convertPathsToPolygons(
					polygonSvgContainer.querySelector("svg"),
					polylinesamplefrequency
				);
				/**
				 * TODO: look into path offset (not stroke?)
				 * This looks promising: https://danmarshall.github.io/svg-path-outline/
				 */

				/**
				 * TODO: look into boolean operations
				 * Likely need to convert SVG paths to polygons first...
				 * Once that's done...
				 * Potentially useful library for boolean operations on the SVG:
				 * https://github.com/junmer/clipper-lib?tab=readme-ov-file
				 */
			}

			/**
			 * PATH TO POLYLINE
			 */
			function buildSvgNode(n, v) {
				n = document.createElementNS("http://www.w3.org/2000/svg", n);
				for (var p in v) n.setAttributeNS(null, p, v[p]);
				return n;
			}

			function convertPathsToPolygons(mySvg, sampleFrequency) {
				const myPaths = mySvg.querySelectorAll(`path`);
				console.log({ mySvg, myPaths });
				for (const myPath of myPaths) {
					myPath.setAttribute("fill", "rgba(0,0,0,0.2)");
					var pathLength = myPath.getTotalLength();
					const numPoints = Math.ceil(pathLength * (sampleFrequency / 100.0));
					console.log({ pathLength, numPoints });
					var polygonPoints = [];
					const points = [];
					console.log({ myPath, pathLength });
					for (var i = 0; i < numPoints; i++) {
						var p = myPath.getPointAtLength((i * pathLength) / numPoints);
						polygonPoints.push(p.x);
						polygonPoints.push(p.y);
						points.push({ x: p.x, y: p.y });
					}
					// append this new polygon child
					const newPolygon = buildSvgNode("polygon", {
						points: polygonPoints.join(","),
						fill: "transparent",
						stroke: "rgba(0,0,0,0.4)",
						"stroke-width": 2,
					});
					mySvg.appendChild(newPolygon);
					for (const polygonPoint of points) {
						const newDot = buildSvgNode("circle", {
							cx: polygonPoint.x,
							cy: polygonPoint.y,
							r: 1.5,
							fill: "#ff0000",
							opacity: "0.9",
							stroke: "none",
						});
						mySvg.appendChild(newDot);
					}
					// TODO: remove the existing path child (mypath)
				}
			}
		</script>
	</body>
</html>
